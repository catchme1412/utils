// http://people.revoledu.com/kardi/
function Run(e) {
	var d = document.getElementById("txtMatrixA").value;
	var b = document.getElementById("txtMatrixB").value;
	var d = getInput(d);
	var b = getInput(b);
	var c = "";
	switch (e) {
	case "ClearInput":
		var a = confirm("This action will delete the input in two boxes. Are you sure?");
		if (a) {
			document.getElementById("txtMatrixA").innerHTML = "";
			document.getElementById("txtMatrixB").innerHTML = ""
		}
		break;
	case "Validate":
		document.getElementById("txtMatrixA").innerHTML = printMatrix(d, false);
		document.getElementById("txtMatrixB").innerHTML = printMatrix(b, false);
		break;
	case "Mahalanobis":
		arr = mahalanobisDistance(d, b);
		c += "Mahalanobis Distance between A and B = " + arr[0].toPrecision(5)
				+ "\n\n\n";
		c += "Group A has " + arr[7] + " observations and " + arr[6]
				+ " features.\n";
		c += "Group B has " + arr[8] + " observations and " + arr[6]
				+ " features.\n\n";
		c += "Mean Difference = \n" + printMatrix(arr[5], true) + "\n";
		c += "Covariance A = \n" + printMatrix(arr[3], true) + "\n";
		c += "Covariance B = \n" + printMatrix(arr[4], true) + "\n";
		c += "Pooled Covariance = \n" + printMatrix(arr[2], true) + "\n";
		c += "Inverse Pooled Covariance = \n" + printMatrix(arr[1], true)
				+ "\n\n";
		c += "The result above was generated by Mahalanobis Distance Program from http://people.revoledu.com/kardi/tutorial/Similarity/MahalanobisDistance.html";
		break;
	case "Help":
		$.fx.speeds._default = 1000;
		$(function() {
			$("#dialog").dialog({
				autoOpen : false,
				show : "blind",
				hide : "explode"
			});
			$("#btnHelp").click(function() {
				$("#dialog").dialog("open");
				return false
			})
		});
		break;
	default:
		break
	}
	document.getElementById("txtResult").innerHTML = c
}
function validateInputFormat(a) {
	var b = document.getElementById(a).value;
	b = b.replace(/[ ]+/g, ", ");
	b = b.replace(/\,+/g, ", ");
	b = b.replace(/\;,/g, ";");
	b = b.replace(/\;$/g, ";\n");
	document.getElementById(a).innerHTML = b
}
function getInput(e) {
	e = rtrim(ltrim(e));
	var b = e.split(";");
	var i = b.length;
	var h = rtrim(ltrim(b[0]));
	h = h.split(",");
	var d = h.length;
	var f = new Array(i);
	for ( var a = 0; a < i; a++) {
		h = rtrim(ltrim(b[a]));
		var g = h.split(",");
		if (g == "") {
			f.pop();
			i--
		} else {
			f[a] = new Array(d);
			for ( var j = 0; j < d; j++) {
				f[a][j] = parseFloat(rtrim(ltrim(g[j])))
			}
		}
	}
	return f
}
function ltrim(a) {
	return a.replace(/^\s+/, "")
}
function rtrim(a) {
	return a.replace(/\s+$/, "")
}
function mahalanobisDistance(h, g) {
	var f = matrixSize(h);
	var s = f[0];
	var e = f[1];
	var c = matrixSize(g);
	var r = c[0];
	var b = c[1];
	if (e != b) {
		return "The number of features  of the two objects must be equal (i.e. columns of matrix A = columns of matrix B)."
	} else {
		var d = matrixMean(h);
		var a = matrixMean(g);
		var l = new Array();
		for ( var k = 0; k < d.length; k++) {
			l[k] = d[k] - a[k]
		}
		l = array2Vector(l);
		var p = matrixCovariance(h);
		var o = matrixCovariance(g);
		n = s + r;
		var q = matrixAddition(matrixScalarMultiple(p, s / n),
				matrixScalarMultiple(o, r / n));
		var m = matrixInverse(q);
		
		
		
		var j = Math.sqrt(matrixMultiplication(matrixTranspose(l),
				matrixMultiplication(m, l)));
		return Array(j, m, q, p, o, l, e, s, r)
	}
}
function matrixCovariance(e, c) {
	if (typeof (c) == "undefined") {
		c = false
	} else {
		c = true
	}
	var a = matrixSize(e);
	var b = a[0];
	var d = a[1];
	if (c) {
		kScalar = 1 / (b - 1)
	} else {
		kScalar = 1 / b
	}
	return matrixScalarMultiple(matrixSumSquare(matrixMeanCorrected(e)),
			kScalar)
}
function matrixMean(h) {
	var a = matrixSize(h);
	var b = a[0];
	var f = a[1];
	var g = new Array();
	for ( var i = 0; i < f; i++) {
		var d = 0;
		for ( var e = 0; e < b; e++) {
			d += h[e][i]
		}
		g[i] = d / b
	}
	return g
}
function matrixSumSquare(a) {
	return matrixMultiplication(matrixTranspose(a), a)
}
function matrixMeanCorrected(h) {
	var b = matrixSize(h);
	var d = b[0];
	var f = b[1];
	var a = matrixZero(d, f);
	var g = matrixMean(h);
	for ( var i = 0; i < f; i++) {
		for ( var e = 0; e < d; e++) {
			a[e][i] = h[e][i] - g[i]
		}
	}
	return a
}
function matrixSize(a) {
	var c = a.length;
	var b = a[0].length;
	return Array(c, b)
}
function matrixZero(b, e) {
	var a = new Array(b);
	for ( var d = 0; d < b; d++) {
		a[d] = new Array(e)
	}
	for ( var d = 0; d < b; d++) {
		for ( var f = 0; f < e; f++) {
			a[d][f] = 0
		}
	}
	return a
}
function matrixTranspose(a) {
	var e = matrixSize(a);
	var d = e[0];
	var g = e[1];
	var b = matrixZero(g, d);
	for ( var h = 0; h < d; h++) {
		for ( var f = 0; f < g; f++) {
			b[f][h] = a[h][f]
		}
	}
	return b
}
function matrixAddition(g, f) {
	var e = matrixSize(g);
	var b = matrixSize(f);
	if (!(e[0] == b[0] && e[1] == b[1])) {
		return "Addition of two matrices can only take place if the two matrices have the same size"
	} else {
		var i = e[0];
		var d = e[1];
		var h = matrixZero(i, d);
		for ( var a = 0; a < i; a++) {
			for ( var j = 0; j < d; j++) {
				h[a][j] = g[a][j] + f[a][j]
			}
		}
		return h
	}
}
function matrixScalarMultiple(h, f) {
	var b = matrixSize(h);
	var d = b[0];
	var g = b[1];
	var a = matrixZero(d, g);
	for ( var e = 0; e < d; e++) {
		for ( var i = 0; i < g; i++) {
			a[e][i] = h[e][i] * f
		}
	}
	return a
}
function matrixMultiplication(h, g) {
	var d = matrixSize(h);
	var a = matrixSize(g);
	if (!(d[1] == a[0])) {
		return "Multiplication of two matrices can only take place if the number of columns in the first matrix is equal to the number of rows in the second matrix"
	} else {
		var b = matrixZero(d[0], a[1]);
		for ( var f = 0; f < d[0]; f++) {
			for ( var i = 0; i < a[1]; i++) {
				for ( var e = 0; e < a[0]; e++) {
					b[f][i] += h[f][e] * g[e][i]
				}
			}
		}
		return b
	}
}
function matrixInverse(d) {
	var a = matrixSize(d);
	var b = a[0];
	var c = a[1];
	if (b != c) {
		return "Matrix inverse can only be performed for a square matrix."
	} else {
		if (matrixDeterminant(d) == 0) {
			return "Matrix is singular (no - inverse)"
		}
		return matrixMoorePenroseInverse(d)
	}
}
function matrixDeterminant(i) {
	var c = matrixSize(i);
	var e = c[0];
	var g = c[1];
	if (e != g) {
		return "Matrix Determinant is only available for a square matrix."
	} else {
		if (e == 2) {
			return (i[0][0] * i[1][1] - i[0][1] * i[1][0])
		} else {
			if (e == 3) {
				return (i[0][0] * (i[1][1] * i[2][2] - i[2][1] * i[1][2])
						- i[0][1] * (i[1][0] * i[2][2] - i[2][0] * i[1][2]) + i[0][2]
						* (i[1][0] * i[2][1] - i[2][0] * i[1][1]))
			} else {
				var b = matrixLUdecomposition(i);
				var a = b[1];
				var h = 1;
				for ( var f = 0; f < e; f++) {
					h *= a[f][f]
				}
				return h
			}
		}
	}
}
function matrixLUdecomposition(f) {
	var e = matrixSize(f);
	var i = e[0];
	var d = e[1];
	if (i != d) {
		return "LU Decomposition can only be performed for a square matrix."
	} else {
		var l = matrixZero(i, d);
		var h = matrixZero(i, d);
		var o = 0;
		var m = new Array();
		for ( var b = 0; b < i; b++) {
			l[b][b] = 1
		}
		for ( var j = 0; j < d; j++) {
			for ( var b = 0; b <= j; b++) {
				for ( var g = 0; g <= b - 1; g++) {
					o += l[b][g] * h[g][j]
				}
				h[b][j] = f[b][j] - o;
				o = 0
			}
			for ( var b = j + 1; b < i; b++) {
				for ( var g = 0; g <= j - 1; g++) {
					o += l[b][g] * h[g][j]
				}
				l[b][j] = 1 / h[j][j] * (f[b][j] - o);
				o = 0
			}
		}
	}
	return Array(l, h)
}
function matrixMoorePenroseInverse(e) {
	var l = 0.000001;
	var h = matrixSingularValueDecomposition(e);
	var g = h[0];
	var b = h[1];
	var f = h[2];
	var i = (0.5 * Math.sqrt(b.length * b[0].length - 1) * b[0][0] * l);
	var d = b.length;
	var k = matrixZero(d, d);
	for ( var a = 0; a < d; a++) {
		for ( var j = 0; j < d; j++) {
			if (a == j && b[a][j] > i) {
				k[a][j] = 1 / b[a][j]
			}
		}
	}
	return matrixMultiplication(f, matrixMultiplication(k, matrixTranspose(g)))
}
function matrixSingularValueDecomposition(S) {
	S = matrixBase0toBase1(S);
	var F = S.length - 1;
	var E = S[1].length - 1;
	var J;
	var K;
	var o;
	var I;
	var P;
	var H;
	var G;
	var b;
	var e = 0;
	var R = 0;
	var O = 0;
	var N = 0;
	var M = 0;
	var D = 0;
	var T = 0;
	var t = 0;
	var r = 0;
	var q = 0;
	var p = new Array(E);
	var N = 0;
	var T = 0;
	var e = 0;
	var A = matrixZero(E + 1, E + 1);
	var B = matrixZero(E + 1, E + 1);
	for (K = 1; K <= E; K++) {
		G = K + 1;
		p[K] = T * N;
		N = 0;
		T = 0;
		D = 0;
		if (K <= F) {
			for (H = K; H <= F; H++) {
				T += Math.abs(S[H][K])
			}
			if (T) {
				for (H = K; H <= F; H++) {
					S[H][K] /= T;
					D += S[H][K] * S[H][K]
				}
				O = S[K][K];
				N = -1 * p_sign(Math.sqrt(D), O);
				M = O * N - D;
				S[K][K] = O - N;
				for (I = G; I <= E; I++) {
					D = 0;
					for (H = K; H <= F; H++) {
						D += S[H][K] * S[H][I]
					}
					O = D / M;
					for (H = K; H <= F; H++) {
						S[H][I] += O * S[H][K]
					}
				}
				for (H = K; H <= F; H++) {
					S[H][K] *= T
				}
			}
		}
		A[K][K] = T * N;
		N = 0;
		T = 0;
		D = 0;
		if (K <= F && K != E) {
			for (H = G; H <= E; H++) {
				T += Math.abs(S[K][H])
			}
			if (T) {
				for (H = G; H <= E; H++) {
					S[K][H] = S[K][H] / T;
					D += S[K][H] * S[K][H]
				}
				O = S[K][G];
				N = -1 * p_sign(Math.sqrt(D), O);
				M = O * N - D;
				S[K][G] = O - N;
				for (H = G; H <= E; H++) {
					p[H] = S[K][H] / M
				}
				for (I = G; I <= F; I++) {
					D = 0;
					for (H = G; H <= E; H++) {
						D += S[I][H] * S[K][H]
					}
					for (H = G; H <= E; H++) {
						S[I][H] += D * p[H]
					}
				}
				for (H = G; H <= E; H++) {
					S[K][H] *= T
				}
			}
		}
		e = max2(e, (Math.abs(A[K][K]) + Math.abs(p[K])))
	}
	for (K = E; K >= 1; K--) {
		if (K < E) {
			if (N) {
				for (I = G; I <= E; I++) {
					B[I][K] = (S[K][I] / S[K][G]) / N
				}
				for (I = G; I <= E; I++) {
					D = 0;
					for (H = G; H <= E; H++) {
						D += S[K][H] * B[H][I]
					}
					for (H = G; H <= E; H++) {
						B[H][I] += D * B[H][K]
					}
				}
			}
			for (I = G; I <= E; I++) {
				B[K][I] = 0;
				B[I][K] = 0
			}
		}
		B[K][K] = 1;
		N = p[K];
		G = K
	}
	for (K = min2(F, E); K >= 1; K--) {
		G = K + 1;
		N = A[K][K];
		for (I = G; I <= E; I++) {
			S[K][I] = 0
		}
		if (N) {
			N = 1 / N;
			for (I = G; I <= E; I++) {
				D = 0;
				for (H = G; H <= F; H++) {
					D += S[H][K] * S[H][I]
				}
				O = (D / S[K][K]) * N;
				for (H = K; H <= F; H++) {
					S[H][I] += O * S[H][K]
				}
			}
			for (I = K; I <= F; I++) {
				S[I][K] *= N
			}
		} else {
			for (I = K; I <= F; I++) {
				S[I][K] = 0
			}
		}
		++S[K][K]
	}
	for (H = E; H >= 1; H--) {
		for (o = 1; o <= 30; o++) {
			J = 1;
			for (G = H; G >= 1; G--) {
				b = G - 1;
				if (parseFloat(Math.abs(p[G]) + e) == e) {
					J = 0;
					break
				}
				if (parseFloat(Math.abs(A[b][b]) + e) == e) {
					break
				}
			}
			if (J) {
				R = 0;
				D = 1;
				for (K = G; K <= H; K++) {
					O = D * p[K];
					p[K] = R * p[K];
					if (parseFloat(Math.abs(O) + e) == e) {
						break
					}
					N = A[K][K];
					M = pythag(O, N);
					A[K][K] = M;
					M = 1 / M;
					R = N * M;
					D = -O * M;
					for (I = 1; I <= F; I++) {
						r = S[I][b];
						q = S[I][K];
						S[I][b] = r * R + q * D;
						S[I][K] = q * R - r * D
					}
				}
			}
			q = A[H][H];
			if (G == H) {
				if (q < 0) {
					A[H][H] = -q;
					for (I = 1; I <= E; I++) {
						B[I][H] = -B[I][H]
					}
				}
				break
			}
			if (o == 30) {
				return "no convergence in 30 SVD iterations"
			}
			t = A[G][G];
			b = H - 1;
			r = A[b][b];
			N = p[b];
			M = p[H];
			O = ((r - q) * (r + q) + (N - M) * (N + M)) / (2 * M * r);
			N = pythag(O, 1);
			O = ((t - q) * (t + q) + M * ((r / (O + p_sign(N, O))) - M)) / t;
			R = 1;
			D = 1;
			for (I = G; I <= b; I++) {
				K = I + 1;
				N = p[K];
				r = A[K][K];
				M = D * N;
				N = R * N;
				q = pythag(O, M);
				p[I] = q;
				R = O / q;
				D = M / q;
				O = t * R + N * D;
				N = N * R - t * D;
				M = r * D;
				r *= R;
				for (P = 1; P <= E; P++) {
					t = B[P][I];
					q = B[P][K];
					B[P][I] = t * R + q * D;
					B[P][K] = q * R - t * D
				}
				q = pythag(O, M);
				A[I][I] = q;
				if (q) {
					q = 1 / q;
					R = O * q;
					D = M * q
				}
				O = R * N + D * r;
				t = R * r - D * N;
				for (P = 1; P <= F; P++) {
					r = S[P][I];
					q = S[P][K];
					S[P][I] = r * R + q * D;
					S[P][K] = q * R - r * D
				}
			}
			p[G] = 0;
			p[H] = O;
			A[H][H] = t
		}
	}
	var L = 0;
	for (I = 1; I <= E; I++) {
		if (A[I][I] > L) {
			L = A[I][I]
		}
	}
	wMin = L * 0.000001;
	for (I = 1; I <= E; I++) {
		if (A[I][I] < wMin) {
			A[I][I] = 0
		}
	}
	var C = matrixBase1toBase0(S);
	var Q = matrixBase1toBase0(A);
	B = matrixBase1toBase0(B);
	return Array(C, Q, B)
}
function max2(d, c) {
	if (d > c) {
		return d
	} else {
		return c
	}
}
function min2(d, c) {
	if (d > c) {
		return c
	} else {
		return d
	}
}
function pythag(d, c) {
	absa = Math.abs(d);
	absb = Math.abs(c);
	if (absa > absb) {
		return absa * Math.sqrt(1 + Math.pow(absb / absa, 2))
	} else {
		return (absb == 0 ? 0 : absb * Math.sqrt(1 + Math.pow(absa / absb, 2)))
	}
}
function p_sign(d, c) {
	if (c >= 0) {
		return Math.abs(d)
	} else {
		return -1 * Math.abs(d)
	}
}
function matrixBase0toBase1(d) {
	var b = d.length;
	var f = d[0].length;
	var a = new Array(b + 1);
	for ( var e = 1; e <= b; e++) {
		a[e] = new Array(f + 1)
	}
	for ( var e = 0; e < b; e++) {
		for ( var g = 0; g < f; g++) {
			a[e + 1][g + 1] = d[e][g]
		}
	}
	return a
}
function matrixBase1toBase0(b) {
	var a = b.length - 1;
	var f = b[1].length - 1;
	var d = new Array(a);
	for ( var e = 0; e < a; e++) {
		d[e] = new Array(f)
	}
	for ( var e = 1; e <= a; e++) {
		for ( var g = 1; g <= f; g++) {
			d[e - 1][g - 1] = b[e][g]
		}
	}
	return d
}
function array2Vector(c) {
	n = c.length;
	var b = new Array(n);
	for ( var d = 0; d < n; d++) {
		b[d] = new Array(1)
	}
	for ( var d = 0; d < n; d++) {
		b[d][0] = c[d]
	}
	return b
}
function printMatrix(b, d) {
	if (typeof (d) == "undefined" | d == true) {
		d = true
	} else {
		d = false
	}
	var a = "";
	for ( var f in b) {
		var h = b[f];
		var e = "";
		for ( var g in h) {
			if (d == true) {
				e += b[f][g].toFixed(4)
			} else {
				e += b[f][g]
			}
			if (g < h.length - 1) {
				e += ", "
			}
		}
		e += ";\n";
		a += e
	}
	return a
};
